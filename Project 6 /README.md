# Google Password Checkup 私有集合交集和（PSI-Sum）协议

## 1. 背景与目的

**Google Password Checkup** 的目标是：**在不泄露双方原始数据的情况下，检查用户的密码（或账户）是否出现在已知泄露数据集中**。

核心是一个私有集合交集和（Private Set Intersection-Sum, PSI-Sum）协议：

- 双方都有一组字符串（如账户标识符）
- 另一方的集合元素还带有一个整数值（如泄露次数、风险分数）
- 协议结束后，一方（P2）得到交集的这些整数值的**和**，但不会知道对方完整集合

## 2. 参与方

- **P1**（客户端，比如浏览器插件）：持有自己的账号列表 ${v_i}$
- **P2**（服务器，比如 Google 服务器）：持有泄露账号及风险值 ${(w_j, t_j)}$

## 3. 核心思路

- 使用 **DDH（Decisional Diffie-Hellman）假设** 的双重幂运算机制，让双方在不知道彼此原始标识符的情况下比较元素是否相等
- 使用 **Paillier 同态加密**，让 P1 可以把交集对应的整数值同态求和，而不看到这些值的明文

## 4. 协议流程

假设群 $G$ 的阶为素数 $p$，生成元 $g$，$H$ 是随机预言机。

### Round 1 (P1 → P2)

- P1 选一个随机秘密指数 $k_1$
- 对每个 $v_i$ 计算 $H(v_i)^{k_1}$ 并打乱顺序发给 P2

### Round 2 (P2 → P1)

- P2 选一个随机秘密指数 $k_2$
- 对收到的 $H(v_i)^{k_1}$ 再做 $k_2$ 次幂，得到 $H(v_i)^{k_1k_2}$（同态指数）
- 对自己的每个 $(w_j, t_j)$：
  - 计算 $H(w_j)^{k_2}$
  - 用 Paillier 加密 $t_j$ 得到 $AEnc(t_j)$
- 把两部分数据发给 P1

### Round 3 (P1 → P2)

- P1 对 P2 发来的 $H(w_j)^{k_2}$ 再做 $k_1$ 次幂 → 得到 $H(w_j)^{k_1k_2}$
- 交集检测：若 $H(w_j)^{k_1k_2}$ 在 Round 2 返回的集合 Z 中，则 $w_j$ 属于交集
- 将交集对应的 $AEnc(t_j)$ 同态相乘（相加），得到交集总和的加密形式，并随机化后发给 P2

### Output (P2)

- P2 用私钥解密，得到交集值的和 $S_J = \sum_{w_j \in J} t_j$

## 5. 协议特性

### 隐私性

- P1 不知道 P2 除交集以外的任何元素和数值
- P2 不知道 P1 除交集外的任何元素

### 高效性

- 双重幂运算是核心比较方法
- Paillier 同态加法只在交集元素上进行

### 安全假设

- DDH 假设保证哈希+幂运算的不可区分性
- Paillier 加密保证值的机密性
