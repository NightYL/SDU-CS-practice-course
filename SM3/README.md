# SM3算法

## 基本信息

- **输出长度**：256位（32字节）
- **分组长度**：512位
- **算法类型**：Merkle-Damgård结构的杂凑函数
- **发布时间**：2010年正式发布为国家标准

## 主要特点

SM3采用了类似SHA-256的设计思路，但在具体实现上有所不同：

- 使用8个32位字作为初始杂凑值
- 消息填充后按512位分组处理
- 每轮使用不同的常数和布尔函数
- 具有良好的雪崩效应和抗碰撞性

## 安全性能

- 抗原像攻击强度：2^256
- 抗第二原像攻击强度：2^256
- 抗碰撞攻击强度：2^128

## 长度扩展攻击

### 攻击原理

当使用`hash(secret||message)`进行消息认证时，攻击者可以在不知道secret的情况下，为扩展后的消息生成有效的哈希值。

### 攻击条件

- 攻击者知道原始消息的哈希值
- 攻击者知道原始消息的长度
- 攻击者不需要知道secret的内容

# Merkle树数学原理详解

## 1. 基础定义

设 $H: {0,1}^* \rightarrow {0,1}^{256}$ 为SM3哈希函数，其中：

- 输入域：任意长度的二进制字符串
- 输出域：256位二进制字符串
- 具有抗碰撞性、单向性和雪崩效应

## 2. RFC6962标准化定义

### 2.1 Merkle Tree Hash (MTH) 函数

RFC6962定义了标准化的MTH函数：

$$MTH(D) = \begin{cases} H(\text{}) & \text{if } |D| = 0 \ H(0x00 \parallel d_0) & \text{if } |D| = 1 \ H(0x01 \parallel MTH(D[0:k]) \parallel MTH(D[k:n])) & \text{if } |D| > 1 \end{cases}$$

其中：

- $D = {d_0, d_1, ..., d_{n-1}}$ 为叶子数据集合
- $k = 2^{\lfloor \log_2(n-1) \rfloor}$ 为最大的2的幂次 ≤ n
- $0x00$ 为叶子节点标识前缀
- $0x01$ 为内部节点标识前缀
- $\parallel$ 表示字符串连接

### 2.2 递归构造过程

**步骤1：叶子哈希计算**

$$h_i^{(0)} = H(0x00 \parallel d_i), \quad i = 0, 1, ..., n-1$$

**步骤2：内部节点递归计算**

对于层级 $j = 1, 2, ..., h$：

$$h_i^{(j)} = H(0x01 \parallel h_{2i}^{(j-1)} \parallel h_{2i+1}^{(j-1)})$$

**步骤3：根节点**

$$\text{root} = h_0^{(h)} = MTH(D)$$

## 3. 存在性证明数学原理

### 3.1 审计路径定义

对于叶子节点 $d_m$ 的存在性证明，审计路径定义为：

$$\text{AuditPath}(m, D) = {(s_0, \delta_0), (s_1, \delta_1), ..., (s_{h-1}, \delta_{h-1})}$$

其中：

- $s_i$ 为第 $i$ 层的兄弟节点哈希值
- $\delta_i \in {0, 1}$ 为方向标识（0=左，1=右）

### 3.2 验证过程

验证算法从叶子向根重构哈希：

**初始化：**

$$v_0 = H(0x00 \parallel d_m)$$

**递归计算：**

$$v_{i+1} = \begin{cases} H(0x01 \parallel v_i \parallel s_i) & \text{if } \delta_i = 0 \ H(0x01 \parallel s_i \parallel v_i) & \text{if } \delta_i = 1 \end{cases}$$

**验证条件：**

$$v_h = \text{root} \Leftrightarrow \text{证明有效}$$

## 4. 安全性分析

### 4.1 抗碰撞性

**定理1**：如果哈希函数 $H$ 具有抗碰撞性，则Merkle树根哈希具有强抗碰撞性。

**证明**：假设存在两个不同的数据集 $D_1 \neq D_2$ 使得 $MTH(D_1) = MTH(D_2)$，则必存在某层节点发生哈希碰撞，与 $H$ 的抗碰撞性矛盾。

### 4.2 不可伪造性

**定理2**：在随机预言模型下，伪造有效存在性证明的概率为 $\text{negl}(\lambda)$。

**证明**：攻击者需要找到一条从伪造叶子到真实根的路径，这等价于找到多个哈希碰撞，概率可忽略不计。

## 5. 复杂度分析

### 5.1 时间复杂度

| 操作             | 时间复杂度           | 说明                   |
| ---------------- | -------------------- | ---------------------- |
| 构建树           | $O(n)$               | 需要计算 $2n-1$ 个节点 |
| 存在性证明生成   | $O(\log n)$          | 沿路径向上遍历         |
| 存在性证明验证   | $O(\log n)$          | 重新计算路径哈希       |
| 不存在性证明生成 | $O(\log n + \log n)$ | 两个存在性证明         |
| 不存在性证明验证 | $O(\log n)$          | 验证两个边界证明       |

### 5.2 空间复杂度

| 数据结构     | 空间复杂度  | 说明             |
| ------------ | ----------- | ---------------- |
| 完整树存储   | $O(n)$      | 只需存储叶子节点 |
| 存在性证明   | $O(\log n)$ | 审计路径长度     |
| 不存在性证明 | $O(\log n)$ | 两个审计路径     |
